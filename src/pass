#!/usr/bin/env bash

PASSRC=${PASSRC:-"$HOME/.passrc"}
PASS_STORE=${PASS_STORE:-"$HOME/.pass/"}

PASSWORD_STORE="$PASS_STORE/passwords/"
OTP_STORE="$PASS_STORE/otp/"
RECUVA_STORE="$PASS_STORE/recovery/"
KEY_STORE="$PASS_STORE/keys/"
MASTER_KEY="$KEY_STORE/master.age"
PASS_KEY="$KEY_STORE/pass.age"
PASS_PUBKEY="$KEY_STORE/pass.pubkey"

ENTROPY_SALT=$(sed -n 's/^ENTROPY_SALT=//p' "$PASSRC")
ENTROPY_ITERATION=$(sed -n 's/^ENTROPY_ITERATION=//p' "$PASSRC")
ENTROPY_AMPLIFICATION=$(sed -n 's/^ENTROPY_AMPLIFICATION=//p' "$PASSRC")

RED="$(tput setaf 196)"
GREEN="$(tput setaf 82)"
BLUE="$(tput setaf 87)"

if ! command -v age &>/dev/null; then
  echo "age could not be found. Please install it."
  exit 1
elif ! command -v git &>/dev/null; then
  echo "git could not be found. Please install it."
  exit 1
elif ! command -v srm &>/dev/null; then
  echo "secure-delete could not be found. Please install it."
  exit 1
elif ! command -v argon2 &>/dev/null; then
  echo "argon2 could not be found. Please install it."
  exit 1
fi

function usage() {
  cat <<EOF
Pass: Password Manager

Usage: $0 [options] <command> [arguments]

Options:
  -a [-s] <salt> [-i] <iteration>
                              Use Entropy Amplification
  -c, --clip                  Copy password to clipboard after password creation
  -f, --force                 Bypass confirmation dialogs. May be destructive.
  -n                          Enable notifications
  -d [zenity]                 Choose a dialog to get passwords
  -h, --help                  Display this help message and exit

Commands:
  cp, copy, clip [-a] <pass-name>
                           Copy password to clipboard
  close                    Remove cached private key
  find <pass-name>         Search passwords and display as a tree
  git <git-args>           Run any Git command in PASS_STORE
  import                   Import passwords from password store
  ls, list                 List all stored passwords in a tree format
  new, gen, generate [-a -f -c] <pass-name> <length>
                           Generate a new password
  rotate [-f]              Rotate all keys and update master password and PIN
  rm, remove [-f] <pass-name>
                           Remove a password entry
  out, output, stdout [-a] <pass-name>
                           Print password to stdout
  setup                    Initialize keys, directories, and git
  version                  Display the current version number

Examples:
  $0 new -c MyAccount 20
  $0 clip MyAccount
  $0 list
  $0 git status
  $0 rotate -f
EOF
}

function version() {
  echo "v.2.0.0"
}

function text() {
  color=$1
  text=$2
  reset=$(tput sgr0)
  echo -e "${color}${text}${reset}"
}

if [[ "$PASS_STORE" != "$HOME"* ]]; then
  text "$RED" "Danger! PASS_STORE is not located within the home directory!"
  text "$BLUE" "PASS_STORE Location: $PASS_STORE"
  text "$BLUE" "Exitting!"
  exit 1
fi

function global_error() {
  error=$?
  [[ "$error" -ne 0 ]] && {
    echo "An error occurred!" >&2
    exit 1
  }
}

function pass_import() {
  PASSWORD_STORE_DIR=${PASSWORD_STORE_DIR:-$HOME/.password-store/}
  if [ ! -d "$PASS_STORE" ]; then
    echo "PASS_STORE not found!"
    exit 1
  fi
  cd "$PASSWORD_STORE_DIR" || exit 1
  find . -type f -name "*.gpg" | while IFS= read -r password_file; do
    password_name=$(sed 's|^.\(.*\).gpg$|\1|' <<<"$password_file")
    password_dir=$(sed 's|^./\(.*\)/[^/]*\.gpg$|\1/|' <<<"$password_file")
    password=$(pass "$password_name" | head -n 1)

    if [ "$(awk -F '/' '{print $1}' <<<"$password_dir")" != "." ]; then
      mkdir -p "$PASSWORD_STORE/$password_dir"
    fi

    echo "$password" | age --encrypt --recipient="$(cat "$PASS_PUBKEY")" -o "$PASSWORD_STORE/$password_name.age"
    val=$?

    if [ $val -ne 0 ]; then
      echo "Error encrypting password: $password_name" >&2
      continue
    fi

    echo "Password $password_name encrypted successfully!"
  done
  text "$RED" "Important note: Only the first line have been copied!"
  text "$RED" "If there were multiline passwords, they are not copied."
  text "$RED" "For OTP keys, use pass-otp import"
  git -C "$PASS_STORE" add . && git -C "$PASS_STORE" commit . -m "Imported passwords from passwordstore"

  find "$PASS_STORE" -type f -exec chmod 600 {} \;
}

function rotate_keys() {
  local TMP_MAIN TMP_PASS TMP_PASSPUBKEY
  local new_pubkey
  TMP_MAIN="$KEY_STORE/main-temp.age"
  TMP_PASS_ROTATE="$KEY_STORE/pass-temp.age"
  TMP_PASSPUBKEY="$KEY_STORE/pass-temp.pubkey"

  if [ "$FORCE" = "true" ]; then
    # Backup files
    cp -r "$PASS_STORE" "$HOME/.pass.bak" && text "$BLUE" "A backup files have been create at \$HOME/.pass.bak"
  else
    text "$RED" "Are you sure you want to rotate your age keys?"
    select choice_continue in "yes" "no"; do
      case $choice_continue in
      yes) break ;;
      no) exit 0 ;;
      esac
    done
    # Backup files
    cp -r "$PASS_STORE" "$HOME/.pass.bak" && text "$BLUE" "A backup files have been create at \$HOME/.pass.bak"
  fi
  if [ ! -d "$PASSWORD_STORE" ]; then
    text "$RED" "Error: Password Store does not exist!"
    exit 1
  fi

  get_age_key private

  age-keygen -o "$TMP_PASS_ROTATE" # Key used for passwords
  age-keygen -o "$TMP_MAIN"        # encryption layer for pass_key

  awk -F 'key: ' '{print $2}' <"$TMP_PASS_ROTATE" | tr -d '\n' >"$TMP_PASSPUBKEY"

  new_pubkey=$(awk -F 'key: ' '{print $2}' <"$TMP_PASS_ROTATE" | tr -d '\n')

  if [ "$ENTROPY_AMPLIFICATION" = "true" ]; then
    unset key
    key=$(get_age_key_amp_get pass)
  fi

  for dir in "$PASSWORD_STORE" "$OTP_STORE" "$RECUVA_STORE"; do
    if [ -d "$dir" ]; then
      find "$dir" -name "*.age" -print0 | while IFS= read -r -d $'\0' file; do
        DECRYPTED_PASSWORD="${file%.age}.txt"
        age --decrypt --identity <(echo "$key") "$file" >"$DECRYPTED_PASSWORD"
        srm "$file"
        age --encrypt --recipient="$new_pubkey" "$DECRYPTED_PASSWORD" >"$file"
        srm "$DECRYPTED_PASSWORD"
        text "$GREEN" "Encrypted $file"
      done
    fi
  done

  global_error
  key_encryption "$TMP_MAIN" "$TMP_PASS_ROTATE" "$TMP_PASSPUBKEY"

  text "$GREEN" "Complete!"
}

function key_encryption() {
  local SETUP_PASS SETUP_MASTER SETUP_PASS_TMP
  SETUP_MASTER=${1:-"$KEY_STORE/master-setup.age"}
  SETUP_PASS=${2:-"$KEY_STORE/pass-setup.age"}
  SETUP_PASS_TMP=${3:-"$KEY_STORE/pass-setup-tmp.age"}

  text "$BLUE" "Create your PIN password. It's recommended to be easier to access, but not stupid."
  text "$BLUE" "You will need to insert this PIN everytime you work with pass"

  if [ "$ENTROPY_AMPLIFICATION" = "true" ]; then
    if ! command -v expect &>/dev/null; then
      text "$RED" "Error: expect could not be found. Please install it."
      setup_error wipe
      exit 1
    fi
    if [ -z "$ENTROPY_ITERATION" ] || [ -z "$ENTROPY_SALT" ]; then
      text "$BLUE" "Note: You may configure your special SALT and ITERATION in your .passrc"
      text "$BLUE" "Falling back to default values"
    fi
    if [[ $(wc -m <<<"$ENTROPY_SALT") -le 10 ]]; then
      text "$RED" "Error: ENTROPY_SALT must be longer than 10 characters." >&2
      exit 1
    fi
    while true; do
      text "$BLUE" "Using Entropy Amplification"
      text "$GREEN" "Insert your PIN password:"
      read -s first_password
      text "$GREEN" "Confirm your PIN password:"
      read -s second_password
      if [ "$first_password" == "$second_password" ]; then
        password="$first_password"
        break
      else
        text "$RED" "Passwords does not match"
      fi
    done
    password=$(echo "$password" | argon2 "${ENTROPY_SALT:-$(hostname)}" -id -t "${ENTROPY_ITERATION:-2}" -m 20 -p 2 | awk '/^Hash:/ {print $2}')

    expect <<EOF
spawn age --passphrase -o "$PASS_KEY" "$SETUP_PASS"
expect "Enter passphrase (leave empty to autogenerate a secure one):"
send "$password\r"
expect "Confirm passphrase:"
send "$password\r"
expect eof
EOF

  else
    age --encrypt --passphrase -o "$PASS_KEY" "$SETUP_PASS"
  fi
  setup_error

  text "$BLUE" "Create your master password. It's recommended to be strong: Use numbers, characters and symbols."
  age --encrypt --passphrase -o "$MASTER_KEY" "$PASS_KEY"
  setup_error

  for file in "$SETUP_PASS" "$SETUP_MASTER" "$PASS_KEY"; do
    [ -f "$file" ] && srm "$file"
  done
}

function setup_error {
  if [ "$1" == "wipe" ]; then
    for file in "$SETUP_PASS" "$SETUP_MASTER" "$PASS_KEY" "$PASS_PUBKEY"; do
      [ -f "$file" ] && srm "$file"
    done
    exit 1
  fi
  error=$?
  [[ "$error" -ne 0 ]] && {
    echo "An error occurred!" >&2
    for file in "$SETUP_PASS" "$SETUP_MASTER" "$PASS_KEY" "$PASS_PUBKEY"; do
      [ -f "$file" ] && srm "$file"
    done
    exit 1
  }
}

function setup() {
  local SETUP_PASS SETUP_MASTER
  SETUP_MASTER="$KEY_STORE/master-setup.age"
  SETUP_PASS_TMP="$KEY_STORE/pass-setup-tmp.age"
  SETUP_PASS="$KEY_STORE/pass-setup.age"

  ENTROPY_SALT=${ENTROPY_SALT:-$(sed -n 's/^ENTROPY_SALT=//p' "$PASSRC")}
  ENTROPY_ITERATION=${ENTROPY_ITERATION:-$(sed -n 's/^ENTROPY_ITERATION=//p' "$PASSRC")}
  ENTROPY_AMPLIFICATION=${ENTROPY_AMPLIFICATION:-$(sed -n 's/^ENTROPY_AMPLIFICATION=//p' "$PASSRC")}

  if [ -f "$MASTER_KEY" ] || [ -f "$PASS_KEY" ] || [ -f "$PASS_PUBKEY" ]; then
    text "$RED" "You already have a previous setup of pass."
    text "$RED" "Do you want to create new keys? (y/N)"
    select choice_continue in "yes" "no"; do
      case $choice_continue in
      yes)
        mv "$PASS_STORE" "$HOME/.pass.bak" && text "$BLUE" "A backup of your PASS_STORE have been created at $HOME/.pass.bak"
        break
        ;;
      no) exit 0 ;;
      esac
    done
  fi

  for file in "$MASTER_KEY" "$PASS_PUBKEY" "$PASS_KEY"; do
    [ -f "$file" ] && srm "$file"
  done

  if [ -d "$PASSWORD_STORE" ]; then
    srm -R "$PASSWORD_STORE"
  fi

  cat <<EOF
  -------------------------------------------------
  -----------------Setting pass up-----------------
  -------------------------------------------------
EOF

  echo

  text "$GREEN" "1. Creating a dedicated directory for pass and its subdirectories"
  echo "mkdir -p \$PASS_STORE \$KEY_STORE \$PASSWORD_STORE"

  mkdir -p "$PASS_STORE" "$KEY_STORE" "$PASSWORD_STORE"
  setup_error

  echo

  text "$GREEN" "2. Creating your master and pass age keys"

  age-keygen -o "$SETUP_PASS_TMP"                                             # pass.age
  awk -F 'key: ' '{print $2}' <"$SETUP_PASS_TMP" | tr -d '\n' >"$PASS_PUBKEY" # pass.age pubkey
  tail -n 1 <"$SETUP_PASS_TMP" >"$SETUP_PASS"                                 # pass.age private key
  srm "$SETUP_PASS_TMP"

  key_encryption

  echo

  text "$RED" "Important Note"
  text "$BLUE" "Your master key have been created. This master key requires your master password. You will need it to decrypt all your passwords."
  text "$BLUE" "master.age is required to decrypt pass.age, and pass.age is required to decrypt all your passwords"
  text "$RED" "Do not forget your master password and your PIN password. If you forget it you will lose access to all your passwords"

  echo

  text "$GREEN" "3. Creating your git repository"
  git -C "$PASS_STORE" init
  git -C "$PASS_STORE" add . && git -C "$PASS_STORE" commit . -m "Initial commit"

  echo

  chmod 600 "$MASTER_KEY"
  text "$GREEN" "Setup Complete"
}

function get_age_key() {
  local KEY TMP_PASS
  ENTROPY_AMPLIFICATION=${ENTROPY_AMPLIFICATION:-$(sed -n 's/^ENTROPY_AMPLIFICATION=//p' "$PASSRC")}
  TMP_PASS=${TMP_PASS:-/run/user/$(id -u)/pass.age.tmp}
  KEY=$1 # expects 'private' or 'public'
  if [ "$KEY" == "public" ]; then
    key=$(cat "$PASS_PUBKEY")
    return 0
  fi
  if [ "$KEY" == "private" ]; then
    if [ ! -f "$TMP_PASS" ]; then
      touch "$TMP_PASS"
      chmod 600 "$TMP_PASS"
      text "$BLUE" "Enter your master password:"
      case "$DIALOG" in
      zenity)
        passphrase=$(zenity --entry --title="Enter master password" --text="Please enter your master password:" --hide-text)
        get_age_key_amp_get master
        ;;
      *)
        age --decrypt "$MASTER_KEY" >"$TMP_PASS"
        ;;
      esac
    fi
    global_error
    if [ "$ENTROPY_AMPLIFICATION" = "true" ]; then
      text "$BLUE" "Enter your PIN password:"
      case "$DIALOG" in
      zenity)
        pin=$(zenity --entry --title="Enter PIN" --text="Please enter your PIN:" --hide-text)
        ;;
      *)
        read -s pin
        ;;
      esac
      pin=$(echo "$pin" | argon2 "${ENTROPY_SALT:-$(hostname)}" -id -t "${ENTROPY_ITERATION:-2}" -m 20 -p 2 | awk '/^Hash:/ {print $2}')
    else
      key=$(age --decrypt "$TMP_PASS")
    fi
    global_error
    return 0
  fi
}

function get_age_key_amp_get() {
  local TMP_PASS MODE
  TMP_PASS=${TMP_PASS:-/run/user/$(id -u)/pass.age.tmp}
  MODE="$1"

  if [ "$MODE" == "pass" ]; then
    key=$(
      expect <<EOF | tr -d '\r' | sed 's/\x1b\[[0-9;]*[A-Za-z]//g' | tr -d '[:space:]' | sed 's/%*$//'
spawn age --decrypt "$TMP_PASS"
expect "Enter passphrase:"
send "$pin\r"
expect eof
EOF
    )
    key=$(echo "$key" | sed 's/.*\(AGE-SECRET-KEY.*\)/\1/')
    echo -n "$key" | tr -d '[:space:]'
  fi

  if [ "$MODE" == "master" ]; then
    expect <<EOF
spawn age --decrypt -o "$TMP_PASS" "$MASTER_KEY"
expect "Enter passphrase:"
send "$passphrase\r"
expect eof
EOF
  fi
}

function git_passwords() {
  git -C "$PASS_STORE" "$@"
}

function output_password() {
  local PASSWORD
  PASSWORD="$PASSWORD_STORE/$name.age"
  get_age_key private
  if [ "$ENTROPY_AMPLIFICATION" = "true" ]; then
    key=$(get_age_key_amp_get pass)
    age --decrypt --identity <(echo "$key") "$PASSWORD"
  else
    age --decrypt --identity <(echo "$key") "$PASSWORD"
  fi
}

function close_password() {
  local TMP_PASS
  TMP_PASS=${TMP_PASS:-/run/user/$(id -u)/pass.age.tmp}
  if [ -f "$TMP_PASS" ]; then
    srm "$TMP_PASS" && text "$GREEN" "Cached private key securely wiped"
    text "$BLUE" "Your secrets are protected behind your master password"
  else
    text "$BLUE" "No cached pass.age found"
  fi
}

function fzf_passwords() {
  if ! command -v fzf &>/dev/null; then
    echo "fzf could not be found. Please install it."
    exit 1
  fi
  if [ -d "$PASSWORD_STORE" ]; then
    cd "$PASSWORD_STORE" || exit 1
    if command -v fzf &>/dev/null; then
      name=$(fzf --prompt "Select a password")
      name=$(awk -F. '{print $1}' <<<"$name" | sed 's|^.\(.*\).gpg$|\1|')
    else
      echo "fzf is not installed"
    fi
  else
    echo "No password store found!"
    echo "Run setup first!"
  fi
}

function find_passwords() {
  if [ -d "$PASSWORD_STORE" ]; then
    cd "$PASSWORD_STORE" || exit 1
    if command -v fd &>/dev/null; then
      fd -t f -i "$name" . | tree --fromfile
    else
      find . -type f -iname "*$name*" | tree --fromfile
    fi
  else
    text "$RED" "No password store found!"
    text "$RED" "Run setup first!"
  fi
}

function list_passwords() {
  if [ -d "$PASSWORD_STORE" ]; then
    if command -v eza &>/dev/null; then
      eza -T "$PASSWORD_STORE"
    else
      tree "$PASSWORD_STORE"
    fi
  else
    text "$RED" "No password store found!"
    text "$RED" "Run setup first!"
  fi
}

function remove_password() {
  local FORCE
  FORCE=${FORCE:-$(sed -n 's/^FORCE=//p' "$PASSRC")}
  if [ "$FORCE" = "true" ]; then
    srm "$PASSWORD_STORE"/"$name".age
    echo "Remove $name from store"
  else
    text "$RED" "Are you sure you want to remove $name? (y/N)"
    select choice_continue in "yes" "no"; do
      case $choice_continue in
      yes) break ;;
      no) exit 0 ;;
      esac
    done
    srm "$PASSWORD_STORE"/"$name".age
    echo "Remove $name from store"
  fi
  error_check
  git -C "$PASS_STORE" add . && git -C "$PASS_STORE" commit . -m "Remove $name from store"
}

function clear_clipboard() {
  local CLIPHIST_WIPE
  CLIPHIST_WIPE=${CLIPHIST_WIPE:-$(sed -n 's/^CLIPHIST_WIPE=//p' "$PASSRC")}
  if [ "$clipmethod" = "x11" ]; then
    echo "" | xclip -sel clip
  elif [ "$clipmethod" = "wayland" ]; then
    echo "" | wl-copy
  fi
  if [ "$CLIPHIST_WIPE" == "true" ]; then
    if command -v cliphist &>/dev/null; then
      cliphist wipe
      exit 1
    else
      echo "Cliphist is not installed"
    fi
  fi
}

function copy_password() {
  local PASSWORD clipmethod
  PASSWORD="$PASSWORD_STORE/$name.age"
  clipmethod="$XDG_SESSION_TYPE"
  NOTIFY=${NOTIFY:$(sed -n 's/^NOTIFY=//p' "$PASSRC")}
  CLIPBOARD_CLEAR_TIME=$(sed -n 's/^CLIPBOARD_CLEAR_TIME=//p' "$PASSRC")
  CLIPBOARD_CLEAR_TIME="${CLIPBOARD_CLEAR_TIME:-5}"

  get_age_key private

  if [ "$clipmethod" = "x11" ]; then
    clip_command="xclip -sel clip"
  elif [ "$clipmethod" = "wayland" ]; then
    clip_command="wl-copy"
  fi

  if [ "$ENTROPY_AMPLIFICATION" = "true" ]; then
    key=$(get_age_key_amp_get pass)
    age --decrypt --identity <(echo "$key") "$PASSWORD" | $clip_command
  else
    age --decrypt --identity <(echo "$key") "$PASSWORD" | $clip_command
  fi

  echo "Clearing the password from clipboard in $CLIPBOARD_CLEAR_TIME seconds..."
  if [ "$NOTIFY" = "true" ]; then
    notify-send -u normal "Pass: Copy" "Clearing the password in $CLIPBOARD_CLEAR_TIME seconds..."
  fi
  sleep "$CLIPBOARD_CLEAR_TIME"s
  clear_clipboard
}

function generate_password() {
  local FORCE PASSWORD PWGEN_OPT
  FORCE=${FORCE:-$(sed -n 's/^FORCE=//p' "$PASSRC")}
  PASSWORD="$PASSWORD_STORE/$name.age"
  CLIP_POST_ACTION=${CLIP_POST_ACTION:-false}

  if [ -z "$name" ]; then
    text "$RED" "Error: No name provided for your password"
    exit 1
  fi

  if ! command -v pwgen &>/dev/null; then
    echo "pwgen could not be found. Please install it."
    exit 1
  fi

  function generate_error() {
    error=$?
    [[ "$error" -ne 0 ]] && {
      echo "An error occurred!" >&2
      if [ -f "$PASSWORD" ]; then
        srm "$PASSWORD"
      fi
      exit 1
    }
  }

  if [ -z "$PWGEN_OPT" ]; then
    PWGEN_OPT="-Bsncy1n"
  fi

  if [ -f "$PASSWORD" ]; then
    text "$BLUE" "This password already exists!"
    if [ "$FORCE" = "true" ]; then
      srm "$PASSWORD"
      text "$RED" "Removed $name from store"
    else
      exit 1
    fi
  fi

  get_age_key public # get pubkey

  cd "$PASSWORD_STORE" || exit 1
  mkdir -p "$(dirname "$name")"

  pwgen "$length" "$PWGEN_OPT" | age --encrypt --recipient="$key" --output="$PASSWORD" # create passwords from pass.age pubkey
  generate_error

  git -C "$PASS_STORE" add . && git -C "$PASS_STORE" commit . -m "Add generated password for $name"
  chmod 600 "$PASSWORD"
  if [ "$CLIP_POST_ACTION" = "true" ]; then
    copy_password
  fi
}

while getopts ":hnafc:d:i:s:" opt; do
  case "$opt" in
  a)
    ENTROPY_AMPLIFICATION=true
    ;;
  n)
    NOTIFY=true
    ;;
  i)
    ENTROPY_ITERATION="$OPTARG"
    ;;
  s)
    ENTROPY_SALT="$OPTARG"
    ;;
  h)
    usage
    exit 0
    ;;
  f) FORCE=true ;;
  d) DIALOG="$OPTARG" ;;
  c)
    CLIP_POST_ACTION=true
    ;;
  ?)
    echo "Error: Invalid option '-$OPTARG'" >&2
    usage
    exit 0
    ;;
  esac
done

shift $((OPTIND - 1))

case "$1" in
-h | --help | usage)
  usage
  exit 0
  ;;
setup)
  setup
  exit 0
  ;;
--clip)
  shift
  CLIP_POST_ACTION=true
  ;;
--force)
  shift
  FORCE=true
  ;;
output | out | stdout)
  shift
  name=$1
  if [[ -z "$name" ]]; then
    fzf_passwords
  fi
  output_password
  exit 0
  ;;
cp | copy | clip)
  shift
  name=$1
  if [[ -z "$name" ]]; then
    fzf_passwords
  fi
  copy_password
  exit 0
  ;;
rotate)
  rotate_keys
  exit 0
  ;;
new | gen | generate)
  shift
  name="$1"
  length=${2:-72}
  PWGEN_OPT="$*"
  generate_password
  exit 0
  ;;
ls | list)
  list_passwords
  exit 0
  ;;
rm | remove)
  shift
  name=$1
  if [[ -z "$name" ]]; then
    fzf_passwords
  fi
  remove_password
  exit 0
  ;;
git)
  shift
  args=$*
  git_passwords "$args"
  exit 0
  ;;
find)
  shift
  name=$1
  find_passwords
  exit 0
  ;;
close)
  close_password
  exit 0
  ;;
--version | version)
  version
  exit 0
  ;;
import)
  pass_import
  exit 0
  ;;
esac
