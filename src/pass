#!/usr/bin/env bash

# Envs

PASSRC=${PASSRC:-"$HOME/.passrc"}
PASS_STORE=${PASS_STORE:-"$HOME/.pass/"}

if [[ "$PASS_STORE" != "$HOME"* ]]; then
  echo "Danger! PASS_STORE is not located within the home directory!"
  echo "PASS_STORE Location: $PASS_STORE"
  echo "Exitting!"
  exit 1
fi

# Global Variables

PASSWORD_STORE="$PASS_STORE/passwords/"
KEY_STORE="$PASS_STORE/keys/"
MAIN_KEY="$KEY_STORE/main.age"
PASS_KEY="$KEY_STORE/pass.age"
TMP_DIR=/run/user/"$(id -u)"
TMP_MAIN_KEY="$TMP_DIR"/tmp_main.600
CLIP_POST_ACTION=false
PASS_PUBKEY="$KEY_STORE/pass.pubkey"

RED="$(tput setaf 196)"
GREEN="$(tput setaf 82)"
BLUE="$(tput setaf 87)"

function usage() {
  cat <<EOF
Pass: Password Manager
Usage: $0 [option] [command]
Available options:
-c, --clip                                  - Copy password to clipboard after generate or edit
-f, --force                                 - Lifts confirmation dialogs
-h, --help, usage                           - Displays this message and exists
-o                                          - Print password to stdout
Available commands:
clip [pass-name]                            - Copy password to clipboard
edit [pass-name]                            - Edit an existing password using nano
find [pass-name]                            - Find files and output as tree format
git [git-args]                              - Run any git coomand at PASS_STORE
import                                      - Import passwords from passwordstore
ls, list                                    - List all passwords in a tree format
new, generate -f -c [pass-name] [length]    - Generate a new password
reset -f                                    - Re-encrypts all passwords with new key and master password
rm, remove -f [pass-name]                   - Remove password from store
setup                                       - Setup keys, directories and git
version                                     - Displays the current version number
EOF
}

function version() {
  echo "v.1.0.0"
}

function text() {
  color=$1
  text=$2
  reset=$(tput sgr0)
  echo -e "${color}${text}${reset}"
}

function error_check() {
  error=$?
  [[ "$error" -ne 0 ]] && {
    echo "An error occurred!" >&2
    exit 1
  }
}

function pass_import() {
  PASSWORD_STORE_DIR=${PASSWORD_STORE_DIR:-$HOME/.password-store/}
  if [ ! -d "$PASS_STORE" ]; then
    echo "PASS_STORE not found!"
    exit 1
  fi
  cd "$PASSWORD_STORE_DIR" || exit 1
  find . -type f -name "*.gpg" | while IFS= read -r password_file; do
    password_name=$(sed 's|^.\(.*\).gpg$|\1|' <<<"$password_file")
    password_dir=$(sed 's|^./\(.*\)/[^/]*\.gpg$|\1/|' <<<"$password_file")
    password=$(pass "$password_name" | head -n 1)

    if [ "$(awk -F '/' '{print $1}' <<<"$password_dir")" != "." ]; then
      mkdir -p "$PASSWORD_STORE/$password_dir"
    fi

    echo "$password" | age --encrypt --recipient="$(cat "$PASS_PUBKEY")" -o "$PASSWORD_STORE/$password_name.age"
    val=$?

    if [ $val -ne 0 ]; then
      echo "Error encrypting password: $password_name" >&2
      continue
    fi

    echo "Password $password_name encrypted successfully!"
  done
  text "$RED" "Important note: Only the first line have been copied!"
  text "$RED" "If there were multiline passwords, they are not copied."
}

function reset() {
  text "$RED" "Are you sure you want to reset your age keys?"
  if [ "$FORCE" = "true" ]; then
    # Backup files
    cp -r "$PASS_STORE" "$HOME/.pass.bak"
    reset_decrypt # Decrypt all passwords
    reset_encrypt # Re-encrypt all passwords with new keys and password
  else
    select choice_continue in "yes" "no"; do
      case $choice_continue in
      yes) break ;;
      no) exit 0 ;;
      esac
    done
    # Backup files
    cp -r "$PASS_STORE" "$HOME/.pass.bak"
  fi
  if [ ! -d "$PASSWORD_STORE" ]; then
    echo "Password Store does not exist!"
    exit 1
  fi
  local ORIGINAL_MAIN_DECRYPTED ORIGINAL_PASS_DECRYPTED TMP_MAIN TMP_PASS TMP_PASSPUBKEY
  local new_pubkey new_main_pubkey
  ORIGINAL_MAIN_DECRYPTED="$KEY_STORE/main-decrypted.age"
  ORIGINAL_PASS_DECRYPTED="$KEY_STORE/pass-decrypted.age"
  TMP_MAIN="$KEY_STORE/main-temp.age"
  TMP_PASS="$KEY_STORE/pass-temp.age"
  TMP_PASSPUBKEY="$KEY_STORE/pass-temp.pubkey"

  # Old Set
  # main.age > main-decrypted.age
  # pass.age > pass-decrypted.age
  # pass.pubkey

  # New Set
  # new main.age > main-temp.age
  # new pass.age > pass-temp.age
  # new pass.pubkey > pass-temp.pubkey

  # Decrypt Original Main Key
  age --decrypt -o "$ORIGINAL_MAIN_DECRYPTED" "$MAIN_KEY"
  error_check
  # Decrypt Original Pass Key
  age --decrypt --identity="$ORIGINAL_MAIN_DECRYPTED" -o "$ORIGINAL_PASS_DECRYPTED" "$PASS_KEY"
  error_check

  # Create new keys
  age-keygen -o "$TMP_PASS" # Key used for passwords
  age-keygen -o "$TMP_MAIN" # encryption layer for pass_key

  # Create new pass.pubkey
  awk -F 'key: ' '{print $2}' <"$TMP_PASS" | tr -d '\n' >"$TMP_PASSPUBKEY"

  new_pubkey=$(awk -F 'key: ' '{print $2}' <"$TMP_PASS" | tr -d '\n')

  find "$PASSWORD_STORE" -name "*.age" -print0 | while IFS= read -r -d $'\0' file; do
    DECRYPTED_PASSWORD="${file%.age}.txt"
    age --decrypt --identity="$ORIGINAL_PASS_DECRYPTED" "$file" >"$DECRYPTED_PASSWORD"
    age --encrypt --recipient="$new_pubkey" "$DECRYPTED_PASSWORD" >"$file"
  done
  error_check

  # Wipe all decrypted passwords
  find "$PASSWORD_STORE" -name "*.txt" -print0 | xargs -0 srm
  srm "$ORIGINAL_MAIN_DECRYPTED" "$ORIGINAL_PASS_DECRYPTED" "$MAIN_KEY" "$PASS_KEY" "$PASS_PUBKEY"
  mv "$TMP_PASSPUBKEY" "$PASS_PUBKEY"

  new_main_pubkey=$(awk -F 'key: ' '{print $2}' <"$TMP_MAIN" | tr -d '\n')

  age --encrypt --recipient="$new_main_pubkey" -o "$PASS_KEY" "$TMP_PASS"
  age --encrypt --passphrase -o "$MAIN_KEY" "$TMP_MAIN"

  srm "$TMP_MAIN" "$TMP_PASS"

  text "$GREEN" "Complete!"
}

# Setup directories, gpg and age keys, and git repository
function setup() {
  if ! command -v age &>/dev/null; then
    echo "age could not be found. Please install it."
    exit 1
  elif ! command -v git &>/dev/null; then
    echo "git could not be found. Please install it."
    exit 1
  elif ! command -v srm &>/dev/null; then
    echo "secure-delete could not be found. Please install it."
    exit 1
  fi

  if [ -f "$TMP_MAIN_KEY" ]; then
    srm "$TMP_MAIN_KEY"
  fi
  text "$GREEN" "Setting up"
  text "$GREEN" "1. Creating a dedicated directory for pass and its subdirectories"
  mkdir -p "$PASS_STORE" "$KEY_STORE" "$PASSWORD_STORE"
  error_check
  echo
  text "$GREEN" "2. Creating your main and pass age keys"
  age-keygen -o "$KEY_STORE/temp_pass" # Key used for passwords
  awk -F 'key: ' '{print $2}' <"$KEY_STORE/temp_pass" | tr -d '\n' >"$PASS_PUBKEY"
  age-keygen -o "$KEY_STORE/temp_main" # encryption layer for pass_key
  main_key=$(awk -F 'key: ' '{print $2}' <"$KEY_STORE/temp_main" | tr -d '\n')
  age --encrypt --recipient="$main_key" -o "$PASS_KEY" "$KEY_STORE/temp_pass"
  error_check
  age --encrypt --passphrase -o "$MAIN_KEY" "$KEY_STORE/temp_main"
  val=$?
  if [ "$val" -ne 0 ]; then
    echo "An error occurred!" >&2
    srm "$KEY_STORE/temp_main" "$KEY_STORE/temp_pass" "$PASS_KEY" "$PASS_PUBKEY"
    exit 1
  fi
  srm "$KEY_STORE/temp_main" "$KEY_STORE/temp_pass"
  echo
  text "$BLUE" "Two keys have been created: main.age and pass.age"
  text "$BLUE" "You will need both to access your accounts. And both are encrypted by default."
  text "$BLUE" "main.age is required to decrypt pass.age, and pass.age is required to decrypt all your passwords"
  text "$BLUE" "You can decrypt main.age with the password you just set"
  text "$RED" "Do not forget your password. If you forget it you will lose access to all your passwords"
  echo
  text "$GREEN" "3. Creating your git repository"
  git -C "$PASS_STORE" init
  git -C "$PASS_STORE" add . && git -C "$PASS_STORE" commit . -m "Initial commit"
  echo
  text "$GREEN" "Setup Complete"
}

# Decrypt main.age to get age pubkey
function get_age_pub_key() {
  local private
  private=$1 # expects 'true'
  pubkey=$(cat "$PASS_PUBKEY")
  error_check
  if [ "$private" = "true" ]; then
    # use main.age tmp file and create a pass.age tmp file (shorter lived than main.age tmp file)
    if [ ! -f "$TMP_MAIN_KEY" ]; then
      touch "$TMP_MAIN_KEY"
      chmod 600 "$TMP_MAIN_KEY"
      age --decrypt "$MAIN_KEY" >"$TMP_MAIN_KEY" # use main.age and create a tmp file
      error_check
    fi
    TMP_PASS_KEY=$(mktemp --tmpdir="$TMP_DIR" tmp_pass.XXXXXX)
    age --decrypt --identity="$TMP_MAIN_KEY" "$PASS_KEY" >"$TMP_PASS_KEY"
  fi
  error_check
}

# List directories using eza or tree
function list_passwords() {
  if [ -d "$PASS_STORE" ]; then
    if command -v eza &>/dev/null; then
      eza -T "$PASS_STORE"
    else
      tree "$PASS_STORE"
    fi
  else
    echo "No password store found!"
    echo "Run setup first!"
  fi
}

function output_password() {
  get_age_pub_key true # get pubkey and create pass.age tmp file
  # use pass.age tmp file to decrypt password to output it
  age --decrypt --identity="$TMP_PASS_KEY" "$PASSWORD_STORE/$name.age"
  unset TMP_PASS_KEY
}

function fzf_passwords() {
  if ! command -v fzf &>/dev/null; then
    echo "fzf could not be found. Please install it."
    exit 1
  fi
  if [ -d "$PASSWORD_STORE" ]; then
    cd "$PASSWORD_STORE" || exit 1
    if command -v fzf &>/dev/null; then
      name=$(fzf --prompt "Select a password")
      name=$(awk -F. '{print $1}' <<<"$name" | sed 's|^.\(.*\).gpg$|\1|')
    else
      echo "fzf is not installed"
    fi
  else
    echo "No password store found!"
    echo "Run setup first!"
  fi
}

function find_passwords() {
  if [ -d "$PASS_STORE" ]; then
    cd "$PASS_STORE" || exit 1
    if command -v fd &>/dev/null; then
      fd -t f -i "$name" . | tree --fromfile
    else
      find . -type f -iname "*$name*" | tree --fromfile
    fi
  else
    echo "No password store found!"
    echo "Run setup first!"
  fi
}

function git_passwords() {
  git -C "$PASS_STORE" "$@"
}

# Generate passwords, with optional length choice
function generate_password() {
  local FORCE pw_options PASSWORD
  FORCE="${FORCE:-false}"
  FORCE=$(sed -n 's/^FORCE=//p' "$PASSRC")
  PASSWORD="$PASSWORD_STORE/$name.age"
  if [ -z "$pw_options" ]; then
    pw_options="-Bsncy1n"
  fi
  if ! command -v pwgen &>/dev/null; then
    echo "pwgen could not be found. Please install it."
    exit 1
  fi
  if [ -f "$PASSWORD" ]; then
    echo "This password already exists!"
    if [ "$FORCE" = "true" ]; then
      srm "$PASSWORD"
      echo "Removed $name from store"
    else
      exit 1
    fi
  fi
  get_age_pub_key # get pubkey

  cd "$PASSWORD_STORE" || exit 1
  mkdir -p "$(dirname "$name")"

  pwgen "$length" "$pw_options" | age --encrypt --recipient="$pubkey" --output="$PASSWORD" # create passwords from pass.age pubkey
  error_check
  chmod 600 "$PASSWORD"
  git -C "$PASS_STORE" add . && git -C "$PASS_STORE" commit . -m "Add generated password for $name"
  if [ "$CLIP_POST_ACTION" = "true" ]; then
    copy_password
  fi
}

# Remove password from store
function remove_password() {
  local FORCE
  FORCE="${FORCE:-false}"
  FORCE=$(sed -n 's/^FORCE=//p' "$PASSRC")
  if [ "$FORCE" = "true" ]; then
    srm "$PASSWORD_STORE"/"$name"/.age
    echo "Remove $name from store"
  else
    text "$RED" "Are you sure you want to remove $name? (y/N)"
    select choice_continue in "yes" "no"; do
      case $choice_continue in
      yes) break ;;
      no) exit 0 ;;
      esac
    done
    srm "$PASSWORD_STORE"/"$name"/.age
    echo "Remove $name from store"
  fi
  error_check
  git -C "$PASS_STORE" add . && git -C "$PASS_STORE" commit . -m "Remove $name from store"
}

# Edit password
function edit_password() {
  local tmp_file decrypted_file PASSWORD
  PASSWORD="$PASSWORD_STORE/$name.age"
  tmp_file="$PASSWORD_STORE/$name.tmp"
  decrypted_file="$(mktemp --tmpdir="$TMP_DIR" tmp_decpass.XXXXXX)"

  get_age_pub_key true # get pubkey and create pass.age tmp file

  if [ -f "$tmp_file" ]; then
    mv "$tmp_file" "$PASSWORD"
  fi

  mv "$PASSWORD_STORE/$name.age" "$tmp_file" # safeguard original password
  # use pass.age tmp file to decrypt password to modify it later
  age --decrypt --identity="$TMP_PASS_KEY" "$tmp_file" >"$decrypted_file" || {
    mv "$tmp_file" "$PASSWORD"
    unset TMP_PASS_KEY "$decrypted_file"
    echo "An error occurred!" >&2
    return 1
  }

  nano "$decrypted_file"

  # use pass.age pubkey to create our new password
  age --encrypt --recipient="$pubkey" -o "$PASSWORD" "$decrypted_file" || {
    mv "$tmp_file" "$PASSWORD"
    unset TMP_PASS_KEY "$decrypted_file"
    echo "An error occurred!" >&2
    return 1
  }

  # clear all tmp files
  unset TMP_PASS_KEY "$decrypted_file"

  chmod 600 "$PASSWORD"
  git -C "$PASS_STORE" add . &&
    git -C "$PASS_STORE" commit -m "Edit $name"

  if [ "$CLIP_POST_ACTION" = "true" ]; then
    copy_password
  fi
}

# Clears clipboard
function clear_clipboard() {
  local CLIPHIST_WIPE
  CLIPHIST_WIPE=$(sed -n 's/^CLIPHIST_WIPE=//p' "$PASSRC")
  CLIPHIST_WIPE="${CLIPHIST_WIPE:-false}"
  if [ "$clipmethod" = "x11" ]; then
    echo "" | xclip -sel clip
  elif [ "$clipmethod" = "wayland" ]; then
    echo "" | wl-copy
  fi
  if [ "$CLIPHIST_WIPE" == "true" ]; then
    if command -v cliphist &>/dev/null; then
      cliphist wipe
      exit 1
    else
      echo "Cliphist is not installed"
    fi
  fi
}

# Copy password to clipboard
function copy_password() {
  local password_file="$PASSWORD_STORE/$name.age"
  local clipmethod="$XDG_SESSION_TYPE"
  local CLIPBOARD_CLEAR_TIME
  CLIPBOARD_CLEAR_TIME=$(sed -n 's/^CLIPBOARD_CLEAR_TIME=//p' "$PASSRC")
  CLIPBOARD_CLEAR_TIME="${CLIPBOARD_CLEAR_TIME:-5}"

  get_age_pub_key true # get pubkey and create pass.age tmp file

  if [ "$clipmethod" = "x11" ]; then
    age --decrypt --identity="$TMP_PASS_KEY" "$password_file" | xclip -sel clip
  elif [ "$clipmethod" = "wayland" ]; then
    age --decrypt --identity="$TMP_PASS_KEY" "$password_file" | wl-copy
  fi
  val=$?
  unset TMP_PASS_KEY

  if [ "$val" -ne 0 ]; then
    echo "An error occurred!" >&2
    return 1
  fi

  # clear all tmp files
  echo "Clearing the password from clipboard in $CLIPBOARD_CLEAR_TIME seconds..."
  sleep "$CLIPBOARD_CLEAR_TIME"s
  clear_clipboard
}

while getopts ":hfco" opt; do
  case "$opt" in
  h)
    usage
    exit 0
    ;;
  f) FORCE=true ;;
  c)
    CLIP_POST_ACTION=true
    ;;
  o)
    shift
    name="$1"
    if [[ -z "$name" ]]; then
      fzf_passwords
    fi
    output_password
    exit 0
    ;;
  ?)
    echo "Error: Invalid option '-$OPTARG'" >&2
    usage
    ;;
  esac
done

shift $((OPTIND - 1))

case "$1" in
-h | --help | usage)
  usage
  exit 0
  ;;
setup)
  setup
  exit 0
  ;;
--clip)
  shift
  CLIP_POST_ACTION=true
  ;;
--force)
  shift
  FORCE=true
  ;;
clip)
  shift
  name=$1
  if [[ -z "$name" ]]; then
    fzf_passwords
  fi
  copy_password
  exit 0
  ;;
reset)
  reset
  exit 0
  ;;
new | generate)
  shift
  name="$1"
  length=${2:-72}
  pw_options="$*"
  generate_password
  exit 0
  ;;
edit)
  shift
  name=$1
  if [[ -z "$name" ]]; then
    fzf_passwords
  fi
  edit_password
  exit 0
  ;;
ls | list)
  list_passwords
  exit 0
  ;;
rm | remove)
  shift
  name=$1
  if [[ -z "$name" ]]; then
    fzf_passwords
  fi
  remove_password
  exit 0
  ;;
git)
  shift
  args=$*
  git_passwords "$args"
  exit 0
  ;;
find)
  shift
  name=$1
  find_passwords
  exit 0
  ;;
--version | version)
  version
  exit 0
  ;;
import)
  pass_import
  exit 0
  ;;
esac
